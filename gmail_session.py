#!/usr/bin/env python3
"""
Gmail Session Manager - Interactive Session-Based Email Management Tool

A persistent interactive session for managing Gmail via IMAP with a clean menu-driven interface.
Maintains connection throughout the session and provides intelligent folder management.

Author: Generated by Kiro AI Assistant
License: MIT
"""

import logging
import getpass
import datetime
import csv
import os
from difflib import get_close_matches

# Try to import optional styling libraries
try:
    from rich.console import Console
    from rich.panel import Panel
    from rich.table import Table
    from rich.prompt import Prompt, Confirm
    from rich.text import Text
    from rich import print as rprint
    RICH_AVAILABLE = True
    console = Console()
except ImportError:
    RICH_AVAILABLE = False
    console = None

from imap_connection import GmailIMAPConnection
from email_operations import EmailOperations
from unsubscribe_processor import UnsubscribeProcessor

# Default configuration
DEFAULT_CONFIG = {
    'request_delay': 1,
    'http_timeout': 10,
    'batch_size': 500
}


class GmailSession:
    """
    Interactive Gmail session manager with persistent connection and menu-driven interface.
    """
    
    def __init__(self):
        self.connection = None
        self.email_ops = None
        self.unsubscribe_proc = None
        self.current_folder = "INBOX"
        self.email_address = None
        self.session_log = []
        self.available_folders = []
        self.cutoff_date = None
        
        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        
        # Reduce noise from requests library
        logging.getLogger("requests").setLevel(logging.WARNING)
        logging.getLogger("urllib3").setLevel(logging.WARNING) 
   
    def print_styled(self, text, style="info"):
        """Print styled text using Rich if available, otherwise plain text."""
        if RICH_AVAILABLE:
            if style == "success":
                console.print(text, style="bold green")
            elif style == "error":
                console.print(text, style="bold red")
            elif style == "warning":
                console.print(text, style="bold yellow")
            elif style == "header":
                console.print(Panel(text, style="bold blue"))
            elif style == "info":
                console.print(text, style="cyan")
            else:
                console.print(text)
        else:
            print(text)
    
    def authenticate(self):
        """
        Simple authentication flow: email ‚Üí password ‚Üí connect ‚Üí show options.
        
        Returns:
            bool: True if authentication successful, False otherwise
        """
        self.print_styled("Gmail IMAP Session - Authentication", "header")
        
        # Step 1: Get email address
        while True:
            if RICH_AVAILABLE:
                email = Prompt.ask("Enter your Gmail address")
            else:
                email = input("Enter your Gmail address: ").strip()
            
            if email and '@' in email and email.endswith(('@gmail.com', '@googlemail.com')):
                self.email_address = email
                break
            else:
                self.print_styled("Please enter a valid Gmail address (must end with @gmail.com)", "error")
        
        # Step 2: Get password (App Password or Regular Password)
        print("\nNote: Use App Password (recommended) or Regular Password")
        print("App Password: 16-character code from Google Account settings")
        print("Regular Password: Your normal Gmail password (requires 'Less Secure Apps' enabled)")
        
        password = getpass.getpass("\nEnter your password: ").strip()
        
        if not password:
            self.print_styled("Password cannot be empty", "error")
            return False
        
        # Step 3: Connect to Gmail server
        try:
            self.print_styled("Connecting to Gmail IMAP server...", "info")
            self.connection = GmailIMAPConnection(self.email_address, password)
            
            if self.connection.connect():
                self.print_styled("‚úÖ Successfully connected to Gmail!", "success")
                
                # Initialize operations
                self.email_ops = EmailOperations(self.connection)
                self.unsubscribe_proc = UnsubscribeProcessor(
                    self.email_ops,
                    DEFAULT_CONFIG['request_delay'],
                    DEFAULT_CONFIG['http_timeout']
                )
                
                # Get available folders
                self.available_folders = self.connection.list_folders()
                self.print_styled(f"Found {len(self.available_folders)} folders in your account", "info")
                
                # Log successful authentication
                self.session_log.append({
                    'timestamp': datetime.datetime.now(),
                    'action': 'authentication',
                    'details': f'Successfully connected to {self.email_address}',
                    'status': 'success'
                })
                
                return True
            else:
                self.print_styled("‚ùå Failed to connect to Gmail", "error")
                self.print_styled("If using regular password, enable 'Less Secure Apps' or use App Password", "info")
                return False
                
        except Exception as e:
            self.print_styled(f"‚ùå Connection error: {e}", "error")
            self.print_styled("Try using App Password: https://myaccount.google.com/apppasswords", "info")
            return False 
   
    def show_main_menu(self):
        """Display the main interactive menu."""
        if RICH_AVAILABLE:
            menu = Panel(
                "[bold cyan]What would you like to do?[/bold cyan]\n\n"
                "[bold]1.[/bold] Delete old emails\n"
                "[bold]2.[/bold] Unsubscribe from newsletters\n"
                "[bold]3.[/bold] List all folders (with counts)\n"
                "[bold]4.[/bold] Change current folder\n"
                "[bold]5.[/bold] Show configuration summary\n"
                "[bold]6.[/bold] Exit",
                title=f"Gmail Session - {self.current_folder}",
                border_style="blue"
            )
            console.print(menu)
        else:
            print("\n" + "="*50)
            print(f"Gmail Session - Current Folder: {self.current_folder}")
            print("="*50)
            print("What would you like to do?")
            print("1. Delete old emails")
            print("2. Unsubscribe from newsletters")
            print("3. List all folders (with counts)")
            print("4. Change current folder")
            print("5. Show configuration summary")
            print("6. Exit")
            print("="*50)
    
    def get_menu_choice(self):
        """Get user's menu choice with validation."""
        while True:
            if RICH_AVAILABLE:
                choice = Prompt.ask("Enter your choice", choices=["1", "2", "3", "4", "5", "6"])
            else:
                choice = input("Enter your choice (1-6): ").strip()
            
            if choice in ['1', '2', '3', '4', '5', '6']:
                return int(choice)
            else:
                self.print_styled("Please enter a number between 1-6", "error")
    

    def delete_old_emails(self):
        """Handle old email deletion with dry-run option."""
        self.print_styled("Delete Old Emails", "header")
        
        # Show special note for All Mail folder
        if self.email_ops.is_gmail_all_mail_folder(self.current_folder):
            self.print_styled("üìß All Mail folder detected!", "info")
            self.print_styled("üí° For permanent deletion, emails will be deleted from their source folders", "info")
            self.print_styled("‚ú® This ensures emails disappear from All Mail completely", "success")
        
        # Get cutoff date
        while True:
            if RICH_AVAILABLE:
                cutoff_input = Prompt.ask(
                    "Enter cutoff date (DD-MMM-YYYY, e.g., 01-Jul-2023)",
                    default=self.cutoff_date or "01-Jan-2023"
                )
            else:
                default_date = self.cutoff_date or "01-Jan-2023"
                cutoff_input = input(f"Enter cutoff date (DD-MMM-YYYY) [{default_date}]: ").strip()
                if not cutoff_input:
                    cutoff_input = default_date
            
            try:
                # Validate date format
                datetime.datetime.strptime(cutoff_input, "%d-%b-%Y")
                self.cutoff_date = cutoff_input
                break
            except ValueError:
                self.print_styled("Invalid date format. Please use DD-MMM-YYYY (e.g., 01-Jul-2023)", "error")
        
        # Select folder if not already selected
        if not self.connection.select_folder(self.current_folder):
            self.print_styled(f"Failed to select folder: {self.current_folder}", "error")
            return
        
        # Search for old emails
        self.print_styled(f"Searching for emails older than {self.cutoff_date} in {self.current_folder}...", "info")
        old_email_ids = self.email_ops.search_old_emails(self.cutoff_date, self.current_folder)
        
        if not old_email_ids:
            self.print_styled("No old emails found to delete", "info")
            return
        
        self.print_styled(f"Found {len(old_email_ids)} emails older than {self.cutoff_date}", "warning")
        
        # Show sample emails
        sample_count = min(5, len(old_email_ids))
        self.print_styled(f"Sample of emails to be deleted (showing first {sample_count}):", "info")
        
        for i, email_id in enumerate(old_email_ids[:sample_count]):
            metadata = self.email_ops.get_email_metadata(email_id)
            if metadata:
                print(f"  {i+1}. '{metadata['subject'][:60]}...' from {metadata['from']}")
        
        if len(old_email_ids) > sample_count:
            print(f"  ... and {len(old_email_ids) - sample_count} more emails")
        
        # Ask for dry run
        if RICH_AVAILABLE:
            dry_run = Confirm.ask("Perform dry run first? (Recommended)")
        else:
            dry_run = input("\nPerform dry run first? (y/n): ").lower().startswith('y')
        
        if dry_run:
            self.print_styled("DRY RUN - No emails will actually be deleted", "warning")
            
            if RICH_AVAILABLE:
                proceed = Confirm.ask("Proceed with actual deletion?")
            else:
                proceed = input("Proceed with actual deletion? (y/n): ").lower().startswith('y')
            
            if not proceed:
                self.print_styled("Email deletion cancelled", "info")
                return
        
        # Choose deletion mode for large batches
        if len(old_email_ids) > 100:
            self.print_styled("Large batch detected. Choose deletion mode:", "info")
            if RICH_AVAILABLE:
                mode = Prompt.ask(
                    "Deletion mode",
                    choices=["fast", "detailed"],
                    default="fast"
                )
            else:
                print("1. Fast mode (bulk deletion, minimal logging)")
                print("2. Detailed mode (individual logging, slower)")
                mode_choice = input("Enter choice (1 or 2): ").strip()
                mode = "fast" if mode_choice == "1" else "detailed"
        else:
            mode = "detailed"
        
        # Perform deletion
        start_time = datetime.datetime.now()
        
        if mode == "fast":
            deleted_count = self.email_ops.delete_old_emails_fast(self.cutoff_date, [self.current_folder])
        else:
            deleted_count = self.email_ops.delete_old_emails_with_logging(self.cutoff_date, [self.current_folder], DEFAULT_CONFIG['batch_size'])
        
        end_time = datetime.datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        # Log the operation
        self.session_log.append({
            'timestamp': start_time,
            'action': 'delete_emails',
            'details': f'Deleted {deleted_count} emails older than {self.cutoff_date} from {self.current_folder}',
            'status': 'success' if deleted_count > 0 else 'no_action',
            'duration': duration,
            'count': deleted_count
        })
        
        if deleted_count > 0:
            self.print_styled(f"‚úÖ Successfully deleted {deleted_count} emails in {duration:.1f} seconds", "success")
        else:
            self.print_styled("No emails were deleted", "info")
    
    def unsubscribe_from_newsletters(self):
        """Handle newsletter unsubscription process."""
        self.print_styled("Unsubscribe from Newsletters", "header")
        
        # Select folder if not already selected
        if not self.connection.select_folder(self.current_folder):
            self.print_styled(f"Failed to select folder: {self.current_folder}", "error")
            return
        
        # Search for unsubscribe emails
        self.print_styled(f"Searching for emails with unsubscribe links in {self.current_folder}...", "info")
        unsubscribe_email_ids = self.email_ops.search_unsubscribe_emails()
        
        if not unsubscribe_email_ids:
            self.print_styled("No emails with unsubscribe links found", "info")
            return
        
        self.print_styled(f"Found {len(unsubscribe_email_ids)} emails with potential unsubscribe links", "info")
        
        # Process unsubscribe links
        start_time = datetime.datetime.now()
        link_results = self.unsubscribe_proc.process_unsubscribe_links(unsubscribe_email_ids)
        
        if not link_results['unique_links']:
            self.print_styled("No valid unsubscribe links found", "info")
            return
        
        # Validate and clean links
        cleaned_links = self.unsubscribe_proc.validate_and_clean_links(link_results['unique_links'])
        
        if not cleaned_links:
            self.print_styled("No valid unsubscribe links after cleaning", "info")
            return
        
        # Show found links
        self.print_styled(f"Found {len(cleaned_links)} unique unsubscribe links:", "info")
        for i, link in enumerate(cleaned_links[:5], 1):
            print(f"  {i}. {link[:80]}...")
        
        if len(cleaned_links) > 5:
            print(f"  ... and {len(cleaned_links) - 5} more links")
        
        # Ask for confirmation
        if RICH_AVAILABLE:
            proceed = Confirm.ask("Send unsubscribe requests to these links?")
        else:
            proceed = input("\nSend unsubscribe requests to these links? (y/n): ").lower().startswith('y')
        
        if not proceed:
            self.print_styled("Unsubscribe process cancelled", "info")
            return
        
        # Send unsubscribe requests
        self.print_styled("Sending unsubscribe requests...", "info")
        request_results = self.unsubscribe_proc.send_unsubscribe_requests_batch(cleaned_links)
        
        end_time = datetime.datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        # Log the operation
        self.session_log.append({
            'timestamp': start_time,
            'action': 'unsubscribe',
            'details': f'Processed {len(cleaned_links)} unsubscribe links, {request_results["successful_requests"]} successful',
            'status': 'success' if request_results["successful_requests"] > 0 else 'partial',
            'duration': duration,
            'successful': request_results["successful_requests"],
            'failed': request_results["failed_requests"]
        })
        
        # Show results
        if request_results["successful_requests"] > 0:
            self.print_styled(f"‚úÖ Successfully sent {request_results['successful_requests']} unsubscribe requests", "success")
        
        if request_results["failed_requests"] > 0:
            self.print_styled(f"‚ö†Ô∏è {request_results['failed_requests']} requests failed", "warning")
        
        self.print_styled(f"Unsubscribe process completed in {duration:.1f} seconds", "info")
    
    def list_all_folders(self, show_counts=True):
        """Display all available folders with optional email counts."""
        self.print_styled("Available Gmail Folders", "header")
        
        if not self.available_folders:
            self.print_styled("No folders found", "error")
            return
        
        # Ask user if they want email counts (can be slow)
        if show_counts:
            if RICH_AVAILABLE:
                get_counts = Confirm.ask("Get email counts for folders? (may be slow for large accounts)", default=True)
            else:
                get_counts = input("Get email counts for folders? (may be slow) [y/n]: ").lower().startswith('y')
        else:
            get_counts = False
        
        if get_counts:
            # Get email counts for all folders (with timeout protection)
            self.print_styled("Getting email counts for folders (this may take a moment)...", "info")
            folder_counts = self.email_ops.get_folders_with_counts(self.available_folders, timeout_per_folder=3)
        else:
            folder_counts = {folder: -2 for folder in self.available_folders}  # -2 = skipped
        
        if RICH_AVAILABLE:
            folder_table = Table(title="Gmail Folders")
            folder_table.add_column("No.", style="cyan", width=4)
            folder_table.add_column("Folder Name", style="white")
            folder_table.add_column("Emails", style="yellow", justify="right")
            folder_table.add_column("Type", style="green")
            
            for i, folder in enumerate(self.available_folders, 1):
                folder_type = "System" if folder.startswith('[Gmail]') else "Custom"
                email_count = folder_counts.get(folder, 0)
                
                # Format email count
                if email_count == -1:
                    count_display = "?"
                    count_style = "?"
                elif email_count == -2:
                    count_display = "-"
                    count_style = "-"
                else:
                    count_display = f"{email_count:,}"
                    count_style = f"[bold]{email_count:,}[/bold]" if folder == self.current_folder else f"{email_count:,}"
                
                if folder == self.current_folder:
                    folder_table.add_row(str(i), f"[bold]{folder}[/bold] (current)", count_style, folder_type)
                else:
                    folder_table.add_row(str(i), folder, count_display, folder_type)
            
            console.print(folder_table)
        else:
            print(f"\nFound {len(self.available_folders)} folders:")
            print("-" * 80)
            print(f"{'No.':<4} {'Folder Name':<35} {'Emails':<10} {'Type'}")
            print("-" * 80)
            for i, folder in enumerate(self.available_folders, 1):
                current_marker = " (current)" if folder == self.current_folder else ""
                folder_type = "System" if folder.startswith('[Gmail]') else "Custom"
                email_count = folder_counts.get(folder, 0)
                folder_display = f"{folder}{current_marker}"
                
                # Format email count
                if email_count == -1:
                    count_display = "?"
                elif email_count == -2:
                    count_display = "-"
                else:
                    count_display = f"{email_count:,}"
                
                print(f"{i:<4} {folder_display:<35} {count_display:<10} {folder_type}")
            print("-" * 80)
        
        # Show notes about count symbols
        if -1 in folder_counts.values():
            self.print_styled("Note: '?' indicates folders where count couldn't be determined quickly", "info")
        if -2 in folder_counts.values():
            self.print_styled("Note: '-' indicates email counts were skipped for faster display", "info")    

    def change_current_folder(self):
        """Change the current working folder with fuzzy matching."""
        self.print_styled("Change Current Folder", "header")
        
        # Show current folder
        self.print_styled(f"Current folder: {self.current_folder}", "info")
        
        # Ask for new folder
        if RICH_AVAILABLE:
            new_folder = Prompt.ask("Enter folder name (or 'list' to see all folders)")
        else:
            new_folder = input("Enter folder name (or 'list' to see all folders): ").strip()
        
        if new_folder.lower() == 'list':
            self.list_all_folders()
            
            if RICH_AVAILABLE:
                choice = Prompt.ask("Enter folder number or name")
            else:
                choice = input("Enter folder number or name: ").strip()
            
            # Try to parse as number first
            try:
                folder_index = int(choice) - 1
                if 0 <= folder_index < len(self.available_folders):
                    new_folder = self.available_folders[folder_index]
                else:
                    self.print_styled("Invalid folder number", "error")
                    return
            except ValueError:
                new_folder = choice
        
        # Try exact match first
        if new_folder in self.available_folders:
            selected_folder = new_folder
        else:
            # Use fuzzy matching
            matches = get_close_matches(new_folder, self.available_folders, n=3, cutoff=0.6)
            
            if not matches:
                self.print_styled(f"No folders found matching '{new_folder}'", "error")
                return
            
            if len(matches) == 1:
                selected_folder = matches[0]
                self.print_styled(f"Auto-corrected '{new_folder}' to '{selected_folder}'", "info")
            else:
                self.print_styled(f"Multiple matches found for '{new_folder}':", "warning")
                for i, match in enumerate(matches, 1):
                    print(f"  {i}. {match}")
                
                if RICH_AVAILABLE:
                    choice = Prompt.ask("Select folder", choices=[str(i) for i in range(1, len(matches)+1)])
                else:
                    choice = input(f"Select folder (1-{len(matches)}): ").strip()
                
                try:
                    selected_folder = matches[int(choice) - 1]
                except (ValueError, IndexError):
                    self.print_styled("Invalid selection", "error")
                    return
        
        # Try to select the folder
        if self.connection.select_folder(selected_folder):
            old_folder = self.current_folder
            self.current_folder = selected_folder
            
            # Log the change
            self.session_log.append({
                'timestamp': datetime.datetime.now(),
                'action': 'change_folder',
                'details': f'Changed folder from {old_folder} to {selected_folder}',
                'status': 'success'
            })
            
            self.print_styled(f"‚úÖ Successfully changed to folder: {selected_folder}", "success")
        else:
            self.print_styled(f"‚ùå Failed to select folder: {selected_folder}", "error")
    
    def show_configuration_summary(self):
        """Display current session configuration."""
        if RICH_AVAILABLE:
            config_table = Table(title="Session Configuration")
            config_table.add_column("Setting", style="cyan")
            config_table.add_column("Value", style="white")
            
            config_table.add_row("Email Address", self.email_address or "Not set")
            config_table.add_row("Current Folder", self.current_folder)
            config_table.add_row("Cutoff Date", self.cutoff_date or "Not set")
            config_table.add_row("Total Folders", str(len(self.available_folders)))
            config_table.add_row("Session Actions", str(len(self.session_log)))
            config_table.add_row("Connection Status", "‚úÖ Connected" if self.connection else "‚ùå Disconnected")
            
            console.print(config_table)
        else:
            print("\n" + "="*50)
            print("SESSION CONFIGURATION")
            print("="*50)
            print(f"Email Address: {self.email_address or 'Not set'}")
            print(f"Current Folder: {self.current_folder}")
            print(f"Cutoff Date: {self.cutoff_date or 'Not set'}")
            print(f"Total Folders: {len(self.available_folders)}")
            print(f"Session Actions: {len(self.session_log)}")
            print(f"Connection Status: {'‚úÖ Connected' if self.connection else '‚ùå Disconnected'}")
            print("="*50)
        
        # Show recent actions
        if self.session_log:
            self.print_styled("\nRecent Actions:", "info")
            for log_entry in self.session_log[-5:]:  # Show last 5 actions
                timestamp = log_entry['timestamp'].strftime("%H:%M:%S")
                action = log_entry['action']
                status = log_entry['status']
                details = log_entry['details']
                
                status_icon = "‚úÖ" if status == "success" else "‚ö†Ô∏è" if status == "partial" else "‚ÑπÔ∏è"
                print(f"  {timestamp} {status_icon} {action}: {details}")
    
    def save_session_log(self):
        """Save session log to a file with user confirmation."""
        if not self.session_log:
            self.print_styled("No actions to save", "info")
            return
        
        if RICH_AVAILABLE:
            save_log = Confirm.ask("Do you want to save this session log to a file?")
        else:
            save_log = input("Do you want to save this session log to a file? (y/n): ").lower().startswith('y')
        
        if not save_log:
            return
        
        # Choose format
        if RICH_AVAILABLE:
            format_choice = Prompt.ask(
                "Choose format",
                choices=["txt", "csv", "md"],
                default="txt"
            )
        else:
            print("Choose format:")
            print("1. Text (.txt)")
            print("2. CSV (.csv)")
            print("3. Markdown (.md)")
            choice = input("Enter choice (1-3) [1]: ").strip() or "1"
            format_map = {"1": "txt", "2": "csv", "3": "md"}
            format_choice = format_map.get(choice, "txt")
        
        # Generate filename
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"gmail_session_{timestamp}.{format_choice}"
        
        try:
            if format_choice == "csv":
                self._save_csv_log(filename)
            elif format_choice == "md":
                self._save_markdown_log(filename)
            else:
                self._save_text_log(filename)
            
            self.print_styled(f"‚úÖ Session log saved to: {filename}", "success")
            
        except Exception as e:
            self.print_styled(f"‚ùå Error saving log: {e}", "error")
    
    def _save_text_log(self, filename):
        """Save session log as text file."""
        with open(filename, 'w', encoding='utf-8') as f:
            f.write("Gmail IMAP Session Log\n")
            f.write("=" * 50 + "\n")
            f.write(f"Email: {self.email_address}\n")
            f.write(f"Session Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Total Actions: {len(self.session_log)}\n\n")
            
            for log_entry in self.session_log:
                f.write(f"Time: {log_entry['timestamp'].strftime('%H:%M:%S')}\n")
                f.write(f"Action: {log_entry['action']}\n")
                f.write(f"Status: {log_entry['status']}\n")
                f.write(f"Details: {log_entry['details']}\n")
                if 'duration' in log_entry:
                    f.write(f"Duration: {log_entry['duration']:.1f}s\n")
                f.write("-" * 30 + "\n")
    
    def _save_csv_log(self, filename):
        """Save session log as CSV file."""
        with open(filename, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['Timestamp', 'Action', 'Status', 'Details', 'Duration'])
            
            for log_entry in self.session_log:
                writer.writerow([
                    log_entry['timestamp'].strftime('%Y-%m-%d %H:%M:%S'),
                    log_entry['action'],
                    log_entry['status'],
                    log_entry['details'],
                    log_entry.get('duration', '')
                ])
    
    def _save_markdown_log(self, filename):
        """Save session log as Markdown file."""
        with open(filename, 'w', encoding='utf-8') as f:
            f.write("# Gmail IMAP Session Log\n\n")
            f.write(f"**Email:** {self.email_address}  \n")
            f.write(f"**Session Date:** {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  \n")
            f.write(f"**Total Actions:** {len(self.session_log)}\n\n")
            
            f.write("## Actions Performed\n\n")
            
            for log_entry in self.session_log:
                status_icon = "‚úÖ" if log_entry['status'] == "success" else "‚ö†Ô∏è" if log_entry['status'] == "partial" else "‚ÑπÔ∏è"
                f.write(f"### {status_icon} {log_entry['action'].title()}\n\n")
                f.write(f"**Time:** {log_entry['timestamp'].strftime('%H:%M:%S')}  \n")
                f.write(f"**Status:** {log_entry['status']}  \n")
                f.write(f"**Details:** {log_entry['details']}  \n")
                if 'duration' in log_entry:
                    f.write(f"**Duration:** {log_entry['duration']:.1f} seconds  \n")
                f.write("\n")
    
    def run_session(self):
        """Main session loop."""
        # Authentication
        if not self.authenticate():
            self.print_styled("Authentication failed. Exiting.", "error")
            return False
        
        # Main interactive loop
        try:
            while True:
                self.show_main_menu()
                choice = self.get_menu_choice()
                
                if choice == 1:
                    self.delete_old_emails()
                elif choice == 2:
                    self.unsubscribe_from_newsletters()
                elif choice == 3:
                    self.list_all_folders()
                elif choice == 4:
                    self.change_current_folder()
                elif choice == 5:
                    self.show_configuration_summary()
                elif choice == 6:
                    # Exit
                    self.print_styled("Exiting Gmail session...", "info")
                    self.save_session_log()
                    break
                
                # Pause before showing menu again
                if not RICH_AVAILABLE:
                    input("\nPress Enter to continue...")
        
        except KeyboardInterrupt:
            self.print_styled("\nSession interrupted by user", "warning")
            self.save_session_log()
        
        finally:
            # Clean disconnect
            if self.connection:
                self.connection.disconnect()
                self.print_styled("‚úÖ Disconnected from Gmail", "success")
        
        return True


def main():
    """Main entry point for the Gmail session tool."""
    session = GmailSession()
    return session.run_session()


if __name__ == "__main__":
    try:
        success = main()
        exit(0 if success else 1)
    except Exception as e:
        print(f"Unexpected error: {e}")
        exit(1)