#!/usr/bin/env python3
"""
Gmail IMAP Cleaner - Main Script

A modular Python script that connects to Gmail using IMAP to perform automated email management:
1. Delete emails older than a specified date
2. Find emails containing unsubscribe links and automatically unsubscribe

Usage:
    python main.py

Author: Generated by Kiro AI Assistant
License: MIT
"""

import logging
import sys
from config import get_user_input, handle_authentication_error, DEFAULT_CONFIG
from imap_connection import GmailIMAPConnection
from email_operations import EmailOperations
from unsubscribe_processor import UnsubscribeProcessor


def setup_logging(log_level=logging.INFO):
    """Configure logging for the application."""
    logging.basicConfig(
        level=log_level,
        format=DEFAULT_CONFIG['log_format'],
        handlers=[logging.StreamHandler()]
    )
    
    # Reduce noise from requests library
    logging.getLogger("requests").setLevel(logging.WARNING)
    logging.getLogger("urllib3").setLevel(logging.WARNING)


def test_date_functions(email_ops):
    """Basic unit tests for date parsing and comparison functions."""
    logging.info("Running date function tests...")
    
    # Test cutoff date parsing
    test_cutoff = "01-Jul-2023"
    parsed_cutoff = email_ops.parse_cutoff_date(test_cutoff)
    if parsed_cutoff is None:
        logging.error("Test failed: Could not parse cutoff date")
        return False
    
    # Test date formatting for IMAP
    formatted_date = email_ops.format_date_for_imap_search(parsed_cutoff)
    if formatted_date != test_cutoff:
        logging.error(f"Test failed: Expected {test_cutoff}, got {formatted_date}")
        return False
    
    # Test email date parsing
    test_email_date = "Mon, 15 Aug 2022 10:30:00 +0000"
    parsed_email_date = email_ops.parse_email_date(test_email_date)
    if parsed_email_date is None:
        logging.error("Test failed: Could not parse email date")
        return False
    
    logging.info("All date function tests passed!")
    return True


def get_date_range_info(cutoff_date_str, email_ops):
    """Get information about the date range for logging purposes."""
    import datetime
    
    cutoff_date = email_ops.parse_cutoff_date(cutoff_date_str)
    if cutoff_date is None:
        return None
    
    now = datetime.datetime.now()
    days_difference = (now - cutoff_date).days
    
    return {
        'cutoff_date': cutoff_date,
        'cutoff_date_formatted': email_ops.format_date_for_imap_search(cutoff_date),
        'current_date': now,
        'days_difference': days_difference,
        'is_future_date': days_difference < 0
    }


def log_operation_summary(operation_summary):
    """Log a summary of all operations performed by the script."""
    logging.info("=" * 60)
    logging.info("OPERATION SUMMARY")
    logging.info("=" * 60)
    logging.info(f"Emails deleted: {operation_summary['emails_deleted']}")
    logging.info(f"Unsubscribe emails found: {operation_summary['unsubscribe_emails_found']}")
    logging.info(f"Unsubscribe links processed: {operation_summary['unsubscribe_links_processed']}")
    logging.info(f"Successful unsubscribes: {operation_summary['successful_unsubscribes']}")
    logging.info(f"Failed unsubscribes: {operation_summary['failed_unsubscribes']}")
    logging.info("=" * 60)


def process_unsubscribe_emails(email_ops, unsubscribe_proc):
    """Process unsubscribe emails and return email IDs."""
    logging.info("=" * 50)
    logging.info("STARTING UNSUBSCRIBE EMAIL SEARCH")
    logging.info("=" * 50)
    
    unsubscribe_email_ids = email_ops.search_unsubscribe_emails()
    
    if not unsubscribe_email_ids:
        logging.info("No unsubscribe emails found")
        email_ops.operation_summary['unsubscribe_emails_found'] = 0
        return []
    
    processed_emails = []
    
    for email_id in unsubscribe_email_ids:
        try:
            # Validate email ID format
            int(email_id)
            processed_emails.append(email_id)
        except ValueError:
            logging.warning(f"Invalid email ID format: {email_id}")
    
    if processed_emails:
        logging.info(f"Processing {len(processed_emails)} unsubscribe emails:")
        
        for email_id in processed_emails[:5]:  # Show first 5 as examples
            metadata = email_ops.get_email_metadata(email_id)
            if metadata:
                logging.info(f"Unsubscribe email {email_id}: '{metadata['subject']}' from {metadata['from']}")
        
        if len(processed_emails) > 5:
            logging.info(f"... and {len(processed_emails) - 5} more emails")
    
    email_ops.operation_summary['unsubscribe_emails_found'] = len(processed_emails)
    
    logging.info("=" * 50)
    logging.info(f"UNSUBSCRIBE EMAIL SEARCH COMPLETED: {len(processed_emails)} emails found")
    logging.info("=" * 50)
    
    return processed_emails


def process_unsubscribe_workflow(email_ids, email_ops, unsubscribe_proc):
    """Complete workflow for processing unsubscribe emails and sending requests."""
    if not email_ids:
        logging.info("No unsubscribe emails to process")
        return
    
    # Extract links from emails
    link_results = unsubscribe_proc.process_unsubscribe_links(email_ids)
    
    if not link_results['unique_links']:
        logging.info("No unsubscribe links found to process")
        return
    
    # Validate and clean links
    cleaned_links = unsubscribe_proc.validate_and_clean_links(link_results['unique_links'])
    
    if not cleaned_links:
        logging.info("No valid unsubscribe links after cleaning")
        return
    
    # Log extracted links
    logging.info("=" * 50)
    logging.info("EXTRACTED UNSUBSCRIBE LINKS")
    logging.info("=" * 50)
    
    for i, link in enumerate(cleaned_links, 1):
        logging.info(f"{i:2d}. {link}")
    
    logging.info("=" * 50)
    
    # Ask for user confirmation
    if not unsubscribe_proc.confirm_unsubscribe_requests(cleaned_links):
        logging.info("Unsubscribe requests cancelled by user")
        return
    
    # Send unsubscribe requests
    request_results = unsubscribe_proc.send_unsubscribe_requests_batch(cleaned_links)
    
    # Update operation summary
    email_ops.operation_summary['unsubscribe_links_processed'] = len(cleaned_links)
    email_ops.operation_summary['successful_unsubscribes'] = request_results['successful_requests']
    email_ops.operation_summary['failed_unsubscribes'] = request_results['failed_requests']


def main():
    """Main function that orchestrates all email management operations."""
    setup_logging()
    
    logging.info("Starting Gmail IMAP Cleaner")
    
    # Main operation loop
    while True:
        # Get configuration from user with retry logic for authentication
        config = None
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            config = get_user_input()
            if config is None:
                logging.info("Script cancelled by user")
                return False
            
            # Try to connect with the provided credentials
            try:
                with GmailIMAPConnection(
                    config['email'], 
                    config['password'],
                    DEFAULT_CONFIG['imap_server'],
                    DEFAULT_CONFIG['imap_port']
                ) as imap_conn:
                    
                    logging.info(f"Target email: {config['email']}")
                    logging.info(f"Cutoff date: {config['cutoff_date']}")
                    
                    # Refine folder selection now that we have a connection
                    from config import refine_folder_selection
                    refine_folder_selection(config, imap_conn)
                    logging.info(f"Selected folders: {', '.join(config['folders'])}")
                    
                    # Initialize operations
                    email_ops = EmailOperations(imap_conn)
                    unsubscribe_proc = UnsubscribeProcessor(
                        email_ops,
                        DEFAULT_CONFIG['request_delay'],
                        DEFAULT_CONFIG['http_timeout']
                    )
                    
                    # Test date functions
                    if not test_date_functions(email_ops):
                        logging.error("Date function tests failed. Please check the implementation.")
                        return False
                    
                    # Get and log date range information
                    date_info = get_date_range_info(config['cutoff_date'], email_ops)
                    if date_info is None:
                        logging.error("Failed to parse cutoff date. Please check the format.")
                        return False
                    
                    if date_info['is_future_date']:
                        logging.warning(f"Cutoff date {config['cutoff_date']} is in the future. No emails will be deleted.")
                    else:
                        logging.info(f"Will delete emails older than {date_info['days_difference']} days (before {config['cutoff_date']})")
                    
                    # Process old emails if requested
                    if config['delete_old']:
                        if config['dry_run']:
                            logging.info("Performing DRY RUN - no emails will actually be deleted")
                            old_email_ids = email_ops.search_old_emails(config['cutoff_date'])
                        
                        if old_email_ids:
                            logging.info(f"DRY RUN: Would delete {len(old_email_ids)} emails")
                            
                            # Show what would be deleted (first 5 as examples)
                            for email_id in old_email_ids[:5]:
                                metadata = email_ops.get_email_metadata(email_id)
                                if metadata:
                                    logging.info(f"Would delete: '{metadata['subject']}' from {metadata['from']}")
                            
                            if len(old_email_ids) > 5:
                                logging.info(f"... and {len(old_email_ids) - 5} more emails")
                            
                            proceed = input("\nProceed with actual deletion? (y/n): ").lower().startswith('y')
                            if proceed:
                                # Ask for deletion mode
                                if len(old_email_ids) > 100:
                                    print(f"\nFound {len(old_email_ids)} emails to delete.")
                                    print("Choose deletion mode:")
                                    print("1. Fast mode (bulk deletion, minimal logging)")
                                    print("2. Detailed mode (individual logging, slower)")
                                    
                                    while True:
                                        choice = input("Enter choice (1 or 2): ").strip()
                                        if choice == '1':
                                            email_ops.delete_old_emails_fast(config['cutoff_date'], config['folders'])
                                            break
                                        elif choice == '2':
                                            email_ops.delete_old_emails_with_logging(config['cutoff_date'], config['folders'], DEFAULT_CONFIG['batch_size'])
                                            break
                                        else:
                                            print("Please enter 1 or 2")
                                else:
                                    # For smaller numbers, use detailed mode
                                    email_ops.delete_old_emails_with_logging(config['cutoff_date'], config['folders'], DEFAULT_CONFIG['batch_size'])
                            else:
                                logging.info("Email deletion cancelled by user")
                        else:
                            logging.info("DRY RUN: No old emails found to delete")
                    else:
                        # Direct deletion without dry run
                        if len(config['folders']) == 1:
                            old_email_ids = email_ops.search_old_emails(config['cutoff_date'], config['folders'][0])
                        else:
                            email_folder_pairs = email_ops.search_old_emails_multiple_folders(config['cutoff_date'], config['folders'])
                            old_email_ids = [pair[0] for pair in email_folder_pairs]
                        
                        if old_email_ids and len(old_email_ids) > 100:
                            print(f"\nFound {len(old_email_ids)} emails to delete.")
                            print("Choose deletion mode:")
                            print("1. Fast mode (bulk deletion, minimal logging)")
                            print("2. Detailed mode (individual logging, slower)")
                            
                            while True:
                                choice = input("Enter choice (1 or 2): ").strip()
                                if choice == '1':
                                    email_ops.delete_old_emails_fast(config['cutoff_date'], config['folders'])
                                    break
                                elif choice == '2':
                                    email_ops.delete_old_emails_with_logging(config['cutoff_date'], config['folders'], DEFAULT_CONFIG['batch_size'])
                                    break
                                else:
                                    print("Please enter 1 or 2")
                        else:
                            email_ops.delete_old_emails_with_logging(config['cutoff_date'], config['folders'], DEFAULT_CONFIG['batch_size'])
                
                # Process unsubscribe emails if requested
                if config['process_unsubscribe']:
                    unsubscribe_emails = process_unsubscribe_emails(email_ops, unsubscribe_proc)
                    
                    if unsubscribe_emails:
                        process_unsubscribe_workflow(unsubscribe_emails, email_ops, unsubscribe_proc)
                    else:
                        logging.info("No unsubscribe emails found to process")
                
                logging.info("All operations completed successfully")
                
                # Log operation summary
                log_operation_summary(email_ops.operation_summary)
                
                # Ask user what to do next
                from config import ask_continue_or_exit
                next_action = ask_continue_or_exit()
                
                if next_action == 'continue':
                    # Reset operation summary for next run
                    email_ops.operation_summary = {
                        'emails_deleted': 0,
                        'unsubscribe_emails_found': 0,
                        'unsubscribe_links_processed': 0,
                        'successful_unsubscribes': 0,
                        'failed_unsubscribes': 0
                    }
                    
                    # Ask what operation to perform
                    print("\nSelect operation to perform:")
                    print("1. Delete old emails")
                    print("2. Process unsubscribe emails")
                    print("3. Both operations")
                    
                    while True:
                        op_choice = input("Enter choice (1-3): ").strip()
                        if op_choice == '1':
                            config['delete_old'] = True
                            config['process_unsubscribe'] = False
                            break
                        elif op_choice == '2':
                            config['delete_old'] = False
                            config['process_unsubscribe'] = True
                            break
                        elif op_choice == '3':
                            config['delete_old'] = True
                            config['process_unsubscribe'] = True
                            break
                        else:
                            print("Please enter 1, 2, or 3.")
                    
                    # Continue with the same connection - don't break the loop
                    continue
                    
                elif next_action == 'new_config':
                    # Break inner loop to get new configuration
                    break
                    
                else:  # exit
                    logging.info("Gmail IMAP Cleaner completed")
                    return True
                
                # If we reach here, successful operation completed
                # Break out of retry loop to continue with outer loop
                break
                
            except ConnectionError as e:
                retry_count += 1
                logging.error(f"Connection failed: {e}")
                
                if retry_count < max_retries:
                    if handle_authentication_error():
                        logging.info(f"Retrying... (Attempt {retry_count + 1}/{max_retries})")
                        continue
                    else:
                        logging.info("User chose not to retry")
                        return False
                else:
                    logging.error("Maximum retry attempts reached")
                    return False
            
            except Exception as e:
                logging.error(f"Unexpected error: {e}")
                return False
        
        # If we reach here, it means we want to get new configuration
        # Continue the outer while loop to get new config
        
    return False


if __name__ == "__main__":
    try:
        success = main()
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        logging.info("Script interrupted by user")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
        sys.exit(1)