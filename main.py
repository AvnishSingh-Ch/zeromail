#!/usr/bin/env python3
"""
Gmail IMAP Cleaner - Enhanced Main Script

A modular Python script that connects to Gmail using IMAP to perform automated email management:
1. Delete emails older than a specified date
2. Find emails containing unsubscribe links and automatically unsubscribe
3. Export logs and unsubscribe digests
4. Command-line argument support
5. Enhanced folder matching and styling

Usage:
    python main.py
    python main.py --email user@gmail.com --cutoff 01-Jul-2023 --dry-run

Author: Generated by Kiro AI Assistant
License: MIT
"""

import logging
import sys
import argparse
import csv
import os
from datetime import datetime
from difflib import get_close_matches

# Try to import optional styling libraries
try:
    from rich.console import Console
    from rich.logging import RichHandler
    from rich.panel import Panel
    from rich.text import Text
    RICH_AVAILABLE = True
    console = Console()
except ImportError:
    RICH_AVAILABLE = False
    console = None

try:
    from colorama import init, Fore, Back, Style
    init()  # Initialize colorama
    COLORAMA_AVAILABLE = True
except ImportError:
    COLORAMA_AVAILABLE = False

from config import get_user_input, handle_authentication_error, DEFAULT_CONFIG, ask_continue_or_exit
from imap_connection import GmailIMAPConnection
from email_operations import EmailOperations
from unsubscribe_processor import UnsubscribeProcessor


def setup_logging(log_level=logging.INFO, use_rich=False):
    """Configure logging for the application with optional rich formatting."""
    if use_rich and RICH_AVAILABLE:
        logging.basicConfig(
            level=log_level,
            format="%(message)s",
            handlers=[RichHandler(console=console, rich_tracebacks=True)]
        )
    else:
        logging.basicConfig(
            level=log_level,
            format=DEFAULT_CONFIG['log_format'],
            handlers=[logging.StreamHandler()]
        )
    
    # Reduce noise from requests library
    logging.getLogger("requests").setLevel(logging.WARNING)
    logging.getLogger("urllib3").setLevel(logging.WARNING)


def print_styled(text, style="info"):
    """Print styled text using available styling libraries."""
    if RICH_AVAILABLE:
        if style == "success":
            console.print(text, style="bold green")
        elif style == "error":
            console.print(text, style="bold red")
        elif style == "warning":
            console.print(text, style="bold yellow")
        elif style == "header":
            console.print(Panel(text, style="bold blue"))
        else:
            console.print(text)
    elif COLORAMA_AVAILABLE:
        if style == "success":
            print(f"{Fore.GREEN}{Style.BRIGHT}{text}{Style.RESET_ALL}")
        elif style == "error":
            print(f"{Fore.RED}{Style.BRIGHT}{text}{Style.RESET_ALL}")
        elif style == "warning":
            print(f"{Fore.YELLOW}{Style.BRIGHT}{text}{Style.RESET_ALL}")
        elif style == "header":
            print(f"{Fore.BLUE}{Style.BRIGHT}{'='*60}")
            print(f"{text}")
            print(f"{'='*60}{Style.RESET_ALL}")
        else:
            print(text)
    else:
        print(text)


def fuzzy_match_folder(user_input, available_folders, threshold=0.6):
    """Use fuzzy matching to find the best folder match."""
    if user_input in available_folders:
        return user_input
    
    # Try exact case-insensitive match first
    for folder in available_folders:
        if user_input.lower() == folder.lower():
            return folder
    
    # Try fuzzy matching
    matches = get_close_matches(user_input, available_folders, n=3, cutoff=threshold)
    
    if matches:
        print_styled(f"\nFolder '{user_input}' not found exactly.", "warning")
        print_styled("Did you mean one of these?", "info")
        for i, match in enumerate(matches, 1):
            print(f"{i}. {match}")
        
        while True:
            choice = input(f"\nSelect folder (1-{len(matches)}) or 'n' for none: ").strip()
            if choice.lower() == 'n':
                return None
            try:
                idx = int(choice) - 1
                if 0 <= idx < len(matches):
                    return matches[idx]
                else:
                    print("Invalid selection.")
            except ValueError:
                print("Please enter a number or 'n'.")
    
    return None


def export_session_log(operation_summary, deleted_emails=None, unsubscribed_links=None):
    """Export session log to a file."""
    if not (deleted_emails or unsubscribed_links):
        return
    
    save_log = input("\nDo you want to save a log of this session to a file? (y/n): ").lower().startswith('y')
    if not save_log:
        return
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"gmail_cleaner_log_{timestamp}.txt"
    
    try:
        with open(log_filename, 'w', encoding='utf-8') as f:
            f.write("Gmail IMAP Cleaner - Session Log\n")
            f.write("=" * 50 + "\n")
            f.write(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            # Operation summary
            f.write("OPERATION SUMMARY:\n")
            f.write(f"Emails deleted: {operation_summary['emails_deleted']}\n")
            f.write(f"Unsubscribe emails found: {operation_summary['unsubscribe_emails_found']}\n")
            f.write(f"Unsubscribe links processed: {operation_summary['unsubscribe_links_processed']}\n")
            f.write(f"Successful unsubscribes: {operation_summary['successful_unsubscribes']}\n")
            f.write(f"Failed unsubscribes: {operation_summary['failed_unsubscribes']}\n\n")
            
            # Deleted emails details
            if deleted_emails:
                f.write("DELETED EMAILS:\n")
                f.write("-" * 30 + "\n")
                for email in deleted_emails:
                    f.write(f"Subject: {email.get('subject', 'N/A')}\n")
                    f.write(f"From: {email.get('from', 'N/A')}\n")
                    f.write(f"Date: {email.get('date_str', 'N/A')}\n")
                    f.write(f"Folder: {email.get('folder', 'N/A')}\n")
                    f.write("-" * 30 + "\n")
            
            # Unsubscribed links
            if unsubscribed_links:
                f.write("\nUNSUBSCRIBE LINKS PROCESSED:\n")
                f.write("-" * 30 + "\n")
                for link_info in unsubscribed_links:
                    f.write(f"URL: {link_info.get('url', 'N/A')}\n")
                    f.write(f"Status: {link_info.get('status', 'N/A')}\n")
                    f.write(f"Email Subject: {link_info.get('email_subject', 'N/A')}\n")
                    f.write("-" * 30 + "\n")
        
        print_styled(f"Session log saved to: {log_filename}", "success")
        
    except Exception as e:
        print_styled(f"Error saving log file: {e}", "error")


def export_unsubscribe_digest(unsubscribed_data):
    """Export unsubscribe digest to a markdown file."""
    if not unsubscribed_data:
        return
    
    save_digest = input("\nDo you want to save a digest of unsubscribed senders? (y/n): ").lower().startswith('y')
    if not save_digest:
        return
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    digest_filename = f"unsubscribe_digest_{timestamp}.md"
    
    try:
        with open(digest_filename, 'w', encoding='utf-8') as f:
            f.write("# Gmail Unsubscribe Digest\n\n")
            f.write(f"**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            f.write(f"**Total Unsubscribes:** {len(unsubscribed_data)}\n\n")
            
            f.write("## Unsubscribed Senders\n\n")
            
            # Group by sender domain
            domains = {}
            for item in unsubscribed_data:
                sender = item.get('sender', 'Unknown')
                domain = sender.split('@')[-1] if '@' in sender else 'Unknown'
                if domain not in domains:
                    domains[domain] = []
                domains[domain].append(item)
            
            for domain, items in sorted(domains.items()):
                f.write(f"### {domain}\n\n")
                for item in items:
                    f.write(f"- **From:** {item.get('sender', 'N/A')}\n")
                    f.write(f"  **Subject:** {item.get('subject', 'N/A')}\n")
                    f.write(f"  **Unsubscribe URL:** {item.get('url', 'N/A')}\n")
                    f.write(f"  **Status:** {'✅ Success' if item.get('success') else '❌ Failed'}\n\n")
        
        print_styled(f"Unsubscribe digest saved to: {digest_filename}", "success")
        
    except Exception as e:
        print_styled(f"Error saving digest file: {e}", "error")


def parse_arguments():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Gmail IMAP Cleaner - Automated email management tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python main.py
  python main.py --email user@gmail.com --cutoff 01-Jul-2023 --dry-run
  python main.py --folder "INBOX" --fast-mode --no-unsubscribe
        """
    )
    
    parser.add_argument('--email', help='Gmail address')
    parser.add_argument('--password', help='Gmail password or app password')
    parser.add_argument('--cutoff', help='Cutoff date (DD-MMM-YYYY format, e.g., 01-Jul-2023)')
    parser.add_argument('--folder', help='Gmail folder to process (default: INBOX)')
    parser.add_argument('--dry-run', action='store_true', help='Perform dry run without actual deletion')
    parser.add_argument('--fast-mode', action='store_true', help='Use fast deletion mode')
    parser.add_argument('--no-unsubscribe', action='store_true', help='Skip unsubscribe processing')
    parser.add_argument('--no-styling', action='store_true', help='Disable colored output')
    parser.add_argument('--export-logs', action='store_true', help='Automatically export logs')
    parser.add_argument('--quiet', action='store_true', help='Reduce output verbosity')
    
    return parser.parse_args()


def test_date_functions(email_ops):
    """Basic unit tests for date parsing and comparison functions."""
    logging.info("Running date function tests...")
    
    # Test cutoff date parsing
    test_cutoff = "01-Jul-2023"
    parsed_cutoff = email_ops.parse_cutoff_date(test_cutoff)
    if parsed_cutoff is None:
        logging.error("Test failed: Could not parse cutoff date")
        return False
    
    # Test date formatting for IMAP
    formatted_date = email_ops.format_date_for_imap_search(parsed_cutoff)
    if formatted_date != test_cutoff:
        logging.error(f"Test failed: Expected {test_cutoff}, got {formatted_date}")
        return False
    
    # Test email date parsing
    test_email_date = "Mon, 15 Aug 2022 10:30:00 +0000"
    parsed_email_date = email_ops.parse_email_date(test_email_date)
    if parsed_email_date is None:
        logging.error("Test failed: Could not parse email date")
        return False
    
    logging.info("All date function tests passed!")
    return True


def get_date_range_info(cutoff_date_str, email_ops):
    """Get information about the date range for logging purposes."""
    cutoff_date = email_ops.parse_cutoff_date(cutoff_date_str)
    if cutoff_date is None:
        return None
    
    now = datetime.now()
    days_difference = (now - cutoff_date).days
    
    return {
        'cutoff_date': cutoff_date,
        'cutoff_date_formatted': email_ops.format_date_for_imap_search(cutoff_date),
        'current_date': now,
        'days_difference': days_difference,
        'is_future_date': days_difference < 0
    }


def log_operation_summary(operation_summary):
    """Log a summary of all operations performed by the script."""
    print_styled("OPERATION SUMMARY", "header")
    print(f"Emails deleted: {operation_summary['emails_deleted']}")
    print(f"Unsubscribe emails found: {operation_summary['unsubscribe_emails_found']}")
    print(f"Unsubscribe links processed: {operation_summary['unsubscribe_links_processed']}")
    print(f"Successful unsubscribes: {operation_summary['successful_unsubscribes']}")
    print(f"Failed unsubscribes: {operation_summary['failed_unsubscribes']}")


def process_unsubscribe_emails(email_ops, unsubscribe_proc):
    """Process unsubscribe emails and return email IDs."""
    print_styled("STARTING UNSUBSCRIBE EMAIL SEARCH", "header")
    
    unsubscribe_email_ids = email_ops.search_unsubscribe_emails()
    
    if not unsubscribe_email_ids:
        logging.info("No unsubscribe emails found")
        email_ops.operation_summary['unsubscribe_emails_found'] = 0
        return []
    
    processed_emails = []
    
    for email_id in unsubscribe_email_ids:
        try:
            # Validate email ID format
            int(email_id)
            processed_emails.append(email_id)
        except ValueError:
            logging.warning(f"Invalid email ID format: {email_id}")
    
    if processed_emails:
        logging.info(f"Processing {len(processed_emails)} unsubscribe emails:")
        
        for email_id in processed_emails[:5]:  # Show first 5 as examples
            metadata = email_ops.get_email_metadata(email_id)
            if metadata:
                logging.info(f"Unsubscribe email {email_id}: '{metadata['subject']}' from {metadata['from']}")
        
        if len(processed_emails) > 5:
            logging.info(f"... and {len(processed_emails) - 5} more emails")
    
    email_ops.operation_summary['unsubscribe_emails_found'] = len(processed_emails)
    
    print_styled(f"UNSUBSCRIBE EMAIL SEARCH COMPLETED: {len(processed_emails)} emails found", "success")
    
    return processed_emails


def process_unsubscribe_workflow(email_ids, email_ops, unsubscribe_proc):
    """Complete workflow for processing unsubscribe emails and sending requests."""
    if not email_ids:
        logging.info("No unsubscribe emails to process")
        return []
    
    # Extract links from emails
    link_results = unsubscribe_proc.process_unsubscribe_links(email_ids)
    
    if not link_results['unique_links']:
        logging.info("No unsubscribe links found to process")
        return []
    
    # Validate and clean links
    cleaned_links = unsubscribe_proc.validate_and_clean_links(link_results['unique_links'])
    
    if not cleaned_links:
        logging.info("No valid unsubscribe links after cleaning")
        return []
    
    # Log extracted links
    print_styled("EXTRACTED UNSUBSCRIBE LINKS", "header")
    
    for i, link in enumerate(cleaned_links, 1):
        logging.info(f"{i:2d}. {link}")
    
    # Ask for user confirmation
    if not unsubscribe_proc.confirm_unsubscribe_requests(cleaned_links):
        logging.info("Unsubscribe requests cancelled by user")
        return []
    
    # Send unsubscribe requests
    request_results = unsubscribe_proc.send_unsubscribe_requests_batch(cleaned_links)
    
    # Update operation summary
    email_ops.operation_summary['unsubscribe_links_processed'] = len(cleaned_links)
    email_ops.operation_summary['successful_unsubscribes'] = request_results['successful_requests']
    email_ops.operation_summary['failed_unsubscribes'] = request_results['failed_requests']
    
    # Prepare unsubscribe data for export
    unsubscribe_data = []
    for detail in request_results['request_details']:
        # Get email info for this link
        email_info = None
        for email_detail in link_results['email_details']:
            if detail['url'] in email_detail['links']:
                email_info = email_detail
                break
        
        unsubscribe_data.append({
            'url': detail['url'],
            'success': detail['success'],
            'status': detail.get('status_code', 'N/A'),
            'sender': email_info['from'] if email_info else 'Unknown',
            'subject': email_info['subject'] if email_info else 'Unknown'
        })
    
    return unsubscribe_data


def main():
    """Main function that orchestrates all email management operations."""
    args = parse_arguments()
    
    # Setup logging with optional styling
    use_rich = RICH_AVAILABLE and not args.no_styling
    setup_logging(logging.DEBUG if not args.quiet else logging.INFO, use_rich)
    
    print_styled("Gmail IMAP Cleaner - Enhanced Version", "header")
    
    # Use command-line arguments if provided, otherwise get user input
    if args.email and args.cutoff:
        config = {
            'email': args.email,
            'password': args.password or input("Enter Gmail password: "),
            'cutoff_date': args.cutoff,
            'folders': [args.folder] if args.folder else ['INBOX'],
            'delete_old': True,
            'process_unsubscribe': not args.no_unsubscribe,
            'dry_run': args.dry_run,
            'fast_mode': args.fast_mode
        }
        print_styled("Using command-line configuration", "info")
    else:
        # Main operation loop
        while True:
            # Get configuration from user with retry logic for authentication
            config = None
            max_retries = 3
            retry_count = 0
            
            while retry_count < max_retries:
                config = get_user_input()
                if config is None:
                    logging.info("Script cancelled by user")
                    return False
                
                # Try to connect with the provided credentials
                try:
                    with GmailIMAPConnection(
                        config['email'], 
                        config['password'],
                        DEFAULT_CONFIG['imap_server'],
                        DEFAULT_CONFIG['imap_port']
                    ) as imap_conn:
                        
                        logging.info(f"Target email: {config['email']}")
                        logging.info(f"Cutoff date: {config['cutoff_date']}")
                        
                        # Enhanced folder selection with fuzzy matching
                        available_folders = imap_conn.list_folders()
                        corrected_folders = []
                        
                        for folder in config['folders']:
                            if folder in available_folders:
                                corrected_folders.append(folder)
                            else:
                                matched_folder = fuzzy_match_folder(folder, available_folders)
                                if matched_folder:
                                    corrected_folders.append(matched_folder)
                                    print_styled(f"Auto-corrected '{folder}' to '{matched_folder}'", "success")
                                else:
                                    print_styled(f"Could not find folder '{folder}'", "error")
                        
                        if not corrected_folders:
                            print_styled("No valid folders selected", "error")
                            continue
                        
                        config['folders'] = corrected_folders
                        logging.info(f"Selected folders: {', '.join(config['folders'])}")
                        
                        # Initialize operations
                        email_ops = EmailOperations(imap_conn)
                        unsubscribe_proc = UnsubscribeProcessor(
                            email_ops,
                            DEFAULT_CONFIG['request_delay'],
                            DEFAULT_CONFIG['http_timeout']
                        )
                        
                        # Test date functions
                        if not test_date_functions(email_ops):
                            logging.error("Date function tests failed. Please check the implementation.")
                            return False
                        
                        # Get and log date range information
                        date_info = get_date_range_info(config['cutoff_date'], email_ops)
                        if date_info is None:
                            logging.error("Failed to parse cutoff date. Please check the format.")
                            return False
                        
                        if date_info['is_future_date']:
                            print_styled(f"Cutoff date {config['cutoff_date']} is in the future. No emails will be deleted.", "warning")
                        else:
                            logging.info(f"Will delete emails older than {date_info['days_difference']} days (before {config['cutoff_date']})")
                        
                        # Storage for export data
                        deleted_emails = []
                        unsubscribed_data = []
                        
                        # Operations loop - keep connection alive for multiple operations
                        while True:
                            # Process old emails if requested
                            if config['delete_old']:
                                if config['dry_run']:
                                    logging.info("Performing DRY RUN - no emails will actually be deleted")
                                    # For dry run, we need to get email IDs from all folders
                                    if len(config['folders']) == 1:
                                        old_email_ids = email_ops.search_old_emails(config['cutoff_date'], config['folders'][0])
                                    else:
                                        email_folder_pairs = email_ops.search_old_emails_multiple_folders(config['cutoff_date'], config['folders'])
                                        old_email_ids = [pair[0] for pair in email_folder_pairs]
                                    
                                    if old_email_ids:
                                        logging.info(f"DRY RUN: Would delete {len(old_email_ids)} emails")
                                        
                                        # Show what would be deleted (first 5 as examples)
                                        for email_id in old_email_ids[:5]:
                                            metadata = email_ops.get_email_metadata(email_id)
                                            if metadata:
                                                logging.info(f"Would delete: '{metadata['subject']}' from {metadata['from']}")
                                        
                                        if len(old_email_ids) > 5:
                                            logging.info(f"... and {len(old_email_ids) - 5} more emails")
                                        
                                        proceed = input("\nProceed with actual deletion? (y/n): ").lower().startswith('y')
                                        if proceed:
                                            # Ask for deletion mode
                                            if len(old_email_ids) > 100:
                                                print(f"\nFound {len(old_email_ids)} emails to delete.")
                                                print("Choose deletion mode:")
                                                print("1. Fast mode (bulk deletion, minimal logging)")
                                                print("2. Detailed mode (individual logging, slower)")
                                                
                                                while True:
                                                    choice = input("Enter choice (1 or 2): ").strip()
                                                    if choice == '1':
                                                        email_ops.delete_old_emails_fast(config['cutoff_date'], config['folders'])
                                                        break
                                                    elif choice == '2':
                                                        email_ops.delete_old_emails_with_logging(config['cutoff_date'], config['folders'], DEFAULT_CONFIG['batch_size'])
                                                        break
                                                    else:
                                                        print("Please enter 1 or 2")
                                            else:
                                                # For smaller numbers, use detailed mode
                                                email_ops.delete_old_emails_with_logging(config['cutoff_date'], config['folders'], DEFAULT_CONFIG['batch_size'])
                                        else:
                                            logging.info("Email deletion cancelled by user")
                                    else:
                                        logging.info("DRY RUN: No old emails found to delete")
                                else:
                                    # Direct deletion without dry run
                                    if len(config['folders']) == 1:
                                        old_email_ids = email_ops.search_old_emails(config['cutoff_date'], config['folders'][0])
                                    else:
                                        email_folder_pairs = email_ops.search_old_emails_multiple_folders(config['cutoff_date'], config['folders'])
                                        old_email_ids = [pair[0] for pair in email_folder_pairs]
                                    
                                    if old_email_ids and len(old_email_ids) > 100:
                                        print(f"\nFound {len(old_email_ids)} emails to delete.")
                                        print("Choose deletion mode:")
                                        print("1. Fast mode (bulk deletion, minimal logging)")
                                        print("2. Detailed mode (individual logging, slower)")
                                        
                                        while True:
                                            choice = input("Enter choice (1 or 2): ").strip()
                                            if choice == '1':
                                                email_ops.delete_old_emails_fast(config['cutoff_date'], config['folders'])
                                                break
                                            elif choice == '2':
                                                email_ops.delete_old_emails_with_logging(config['cutoff_date'], config['folders'], DEFAULT_CONFIG['batch_size'])
                                                break
                                            else:
                                                print("Please enter 1 or 2")
                                    else:
                                        email_ops.delete_old_emails_with_logging(config['cutoff_date'], config['folders'], DEFAULT_CONFIG['batch_size'])
                            
                            # Process unsubscribe emails if requested
                            if config['process_unsubscribe']:
                                unsubscribe_emails = process_unsubscribe_emails(email_ops, unsubscribe_proc)
                                
                                if unsubscribe_emails:
                                    unsubscribed_data = process_unsubscribe_workflow(unsubscribe_emails, email_ops, unsubscribe_proc)
                                else:
                                    logging.info("No unsubscribe emails found to process")
                            
                            print_styled("All operations completed successfully", "success")
                            
                            # Log operation summary
                            log_operation_summary(email_ops.operation_summary)
                            
                            # Export logs if requested or auto-export enabled
                            if args.export_logs or not args.email:
                                export_session_log(email_ops.operation_summary, deleted_emails, unsubscribed_data)
                                export_unsubscribe_digest(unsubscribed_data)
                            
                            # Ask user what to do next (only in interactive mode)
                            if not args.email:
                                next_action = ask_continue_or_exit()
                                
                                if next_action == 'continue':
                                    # Reset operation summary for next run
                                    email_ops.operation_summary = {
                                        'emails_deleted': 0,
                                        'unsubscribe_emails_found': 0,
                                        'unsubscribe_links_processed': 0,
                                        'successful_unsubscribes': 0,
                                        'failed_unsubscribes': 0
                                    }
                                    
                                    # Ask what operation to perform
                                    print("\nSelect operation to perform:")
                                    print("1. Delete old emails")
                                    print("2. Process unsubscribe emails")
                                    print("3. Both operations")
                                    
                                    while True:
                                        op_choice = input("Enter choice (1-3): ").strip()
                                        if op_choice == '1':
                                            config['delete_old'] = True
                                            config['process_unsubscribe'] = False
                                            break
                                        elif op_choice == '2':
                                            config['delete_old'] = False
                                            config['process_unsubscribe'] = True
                                            break
                                        elif op_choice == '3':
                                            config['delete_old'] = True
                                            config['process_unsubscribe'] = True
                                            break
                                        else:
                                            print("Please enter 1, 2, or 3.")
                                    
                                    # Continue with operations in the same connection
                                    continue
                                    
                                elif next_action == 'new_config':
                                    # Break out of operations loop and connection to get new configuration
                                    break
                                    
                                else:  # exit
                                    print_styled("Gmail IMAP Cleaner completed", "success")
                                    return True
                            else:
                                # In CLI mode, exit after one run
                                print_styled("Gmail IMAP Cleaner completed", "success")
                                return True
                            
                            # If we reach here, successful operation completed
                            # Break out of retry loop to continue with outer loop
                            break
                            
                except ConnectionError as e:
                    retry_count += 1
                    print_styled(f"Connection failed: {e}", "error")
                    
                    if retry_count < max_retries:
                        if handle_authentication_error():
                            logging.info(f"Retrying... (Attempt {retry_count + 1}/{max_retries})")
                            continue
                        else:
                            logging.info("User chose not to retry")
                            return False
                    else:
                        print_styled("Maximum retry attempts reached", "error")
                        return False
                
                except Exception as e:
                    print_styled(f"Unexpected error: {e}", "error")
                    return False
            
            # If we reach here, it means we want to get new configuration
            # Continue the outer while loop to get new config
            
        return False


if __name__ == "__main__":
    try:
        success = main()
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        print_styled("Script interrupted by user", "warning")
        sys.exit(1)
    except Exception as e:
        print_styled(f"Unexpected error: {e}", "error")
        sys.exit(1)